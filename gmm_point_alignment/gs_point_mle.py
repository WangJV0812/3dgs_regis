import taichi as ti
from torch import diff
import troch

from gmm_point_alignment.gs_scene_voxel_creation import GaussianPointMatcherConfig
from misc.geometry import (
    gaussian_density_cov_inv_ti,
)




@ti.kernel
def forward_point_gaussian_mle(
    K: ti.i32,
    pointcloud: ti.types.ndarray(dtype=ti.f32, ndim=2),                 # (N, 3)
    topk_relations: ti.types.ndarray(dtype=ti.i32, ndim=2),             # (N, K)
    means: ti.types.ndarray(dtype=ti.f32, ndim=3),                      # (M, 3)
    covariances_inv: ti.types.ndarray(dtype=ti.f32, ndim=4),            # (M, 3, 3)
    normalized_factors: ti.types.ndarray(dtype=ti.f32, ndim=1),         # (M,)
    opacities: ti.types.ndarray(dtype=ti.f32, ndim=1),                  # (M,)
    # tmp
    alpha_buffer: ti.types.ndarray(dtype=ti.f32, ndim=1),               # (M,)
    # output
    log_likelihoods: ti.types.ndarray(dtype=ti.f32, ndim=1)             # (N,)
):
    # step 1. calculate the gmm weighted alpha for each gaussian sphere
    sphere_counts = means.shape[0]
    for sphere_idx in range(sphere_counts):
        
        local_cov_inv = ti.Matrix.zero(ti.f32, 3, 3)
        
        for i, j in ti.static(ti.ndrange(3, 3)):
            local_cov_inv[i, j] = covariances_inv[sphere_idx, i, j]
                
        alpha_buffer[sphere_idx] = opacities[sphere_idx] / (gaussian_density_cov_inv_ti(local_cov_inv) + 1e-8)
     
    # step 2. calculate the log probability for each point to be generated by each gaussian sphere
    point_counts = pointcloud.shape[0]
    for point_idx in range(point_counts):
        
        point = ti.math.vec3([pointcloud[point_idx, i] for i in range(3)])

        # load topk related gaussian spheres indices into local variable
        local_indices = ti.Vector([topk_relations[point_idx, k] for k in range(K)])
        sum_exp = 0.0
        
        for k in ti.static(range(K)):
            if local_indices[k] < 0:
                sum_exp = sum_exp + (1e-8)  # if no valid sphere, add a small value to prevent log(0)
                continue
            
            sphere_idx = local_indices[k]
            
            diff = point - ti.math.vec3([
                means[sphere_idx][0], means[sphere_idx][1], means[sphere_idx][2]
            ])
            
            local_covariance_inv = ti.Matrix.zero(ti.f32, 3, 3)
            for i, j in ti.static(ti.ndrange(3, 3)):
                local_covariance_inv[i, j] = covariances_inv[sphere_idx, i, j]
                
            mahal = (diff.transpose() @ local_covariance_inv @ diff)
            
            sum_exp += alpha_buffer[sphere_idx] * ti.exp(-0.5 * mahal + normalized_factors[sphere_idx])
        
        log_likelihoods[point_idx] = ti.math.log(sum_exp + 1e-8)
        
    